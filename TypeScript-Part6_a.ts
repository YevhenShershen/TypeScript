//============КЛАССЫ (Part-1)
class Point {}

//--strictPropertyInitialization
//Настройка strictPropertyInitialization определяет, должны ли поля класса инициализироваться в конструкторе.
class GoodGreeter {
  name: string;

  constructor() {
    this.name = "привет";
  }
}
//Обратите внимание, что поля классов должны быть инициализированы в самом конструкторе.
// TS не анализирует методы, вызываемые в конструкторе, для обнаружения инициализации,
// поскольку производный класс может перезаписать такие методы, и члены не будут инициализированы.

//Если вы намерены инициализировать поле вне конструктора, можете использовать оператор
//утверждения определения присвоения (definite assignment assertion operator, !):
class OKGreeter {
  // Не инициализируется, но ошибки не возникает

  name!: string;
}
//readonly
//Перед названием поля можно указать модификатор readonly. Это запретит присваивать полю значения за пределами конструктора.
class Greeter {
  readonly name: string = "народ";
}

//==============Конструкторы (constructors)
//Конструкторы класса очень похожи на функции. Мы можем добавлять в них параметры с аннотациями типа, значения по умолчанию и перегрузки:

//Однако, между сигнатурами конструктора класса и функции существует несколько отличий:
//1)Конструкторы не могут иметь параметров типа — это задача возлагается на внешнее определение класса, о чем мы поговорим позже
//2)Конструкторы не могут иметь аннотацию возвращаемого типа — всегда возвращается тип экземпляра класса

//super
//Как и в JS, при наличии базового класса в теле конструктора, перед использованием this необходимо вызывать super():

class Base {
  k = 4;
}

class Derived extends Base {
  constructor() {
    // В ES5 выводится неправильное значение, в ES6 выбрасывается исключение
    //super();
    console.log(this.k);

    // 'super' must be called before accessing 'this' in the constructor of a derived class.
    super();
    // Перед доступом к 'this' в конструкторе или производном классе необходимо вызвать 'super'
  }
}

//=============Методы (methods)
//Метод — это свойство класса, значением которого является функция.
//Методы могут использовать такие же аннотации типа, что и функции с конструкторами:

//Обратите внимание, что в теле метода к полям и другим методам по-прежнему следует обращаться через this.
let x: number = 0;

class C {
  x: string = "привет";

  m() {
    // Здесь мы пытаемся изменить значение переменной `x`, находящейся на первой строке, а не свойство класса
    //this
    x = "world";

    // Type 'string' is not assignable to type 'number'.
  }
}

//===========Геттеры/сеттеры
//Классы могут иметь акцессоры (вычисляемые свойства, accessors):
class C1 {
  _length = 0;
  get length() {
    return this._length;
  }
  set length(value) {
    this._length = value;
  }
}
//TS имеет несколько специальных правил, касающихся предположения типов в случае с акцессорами:
//1)Если set отсутствует, свойство автоматически становится readonly
//2)Параметр типа сеттера предполагается на основе типа, возвращаемого геттером
//3)Если параметр сеттера имеет аннотацию типа, она должна совпадать с типом, возвращаемым геттером
//4)Геттеры и сеттеры должны иметь одинаковую видимость членов (см. ниже)

//===Сигнатуры индекса (index signatures)
//Классы могут определять сигнатуры индекса. Они работают также, как сигнатуры индекса в других объектных типах:
class MyClass {
  [s: string]: boolean | ((s: string) => boolean);

  check(s: string) {
    return this[s] as boolean;
  }
}

//=============Классы и наследование
//Как и в других объектно-ориентированных языках, классы в JS могут наследовать членов других классов.

//implements
//implements используется для проверки соответствия класса определенному interface. При несоответствии класса интерфейсу возникает ошибка:
interface Pingable {
  ping(): void;
}

class Sonar implements Pingable {
  ping() {
    console.log("пинг!");
  }
}

class Ball implements Pingable {
  // Class 'Ball' incorrectly implements interface 'Pingable'. Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.
  // Класс 'Ball' некорректно реализует интерфейс 'Pingable'. Свойство 'ping' отсутствует в типе 'Ball', но является обязательным в типе 'Pingable'
  pong() {
    console.log("понг!");
  }
}

//==========Предостережение
//Важно понимать, что implements всего лишь проверяет,
// соответствует ли класс определенному интерфейсу.
//Он не изменяет тип класса или его методов. Ошибочно полагать, что implements изменяет тип класса — это не так!

//=======extends
//Классы могут расширяться другими классами.
//Производный класс получает все свойства и методы базового, а также может определять дополнительных членов.
class Animal {
  move() {
    console.log("Moving along!");
  }
}

class Dog extends Animal {
  woof(times: number) {
    for (let i = 0; i < times; i++) {
      console.log("woof!");
    }
  }
}
const d = new Dog();
// Метод базового класса
d.move();
// Метод производного класса
d.woof(3);

//====Перезапись методов
//Производный класс может перезаписывать свойства и методы базового класса.
// Для доступа к методам базового класса можно использовать синтаксис super.
//Поскольку классы в JS — это всего лишь объекты для поиска (lookup objects),
//такого понятия как «супер-поле» не существует.
class Base1 {
  greet() {
    console.log("Привет, народ!");
  }
}

class Derived1 extends Base1 {
  //Работает потому что параметр не обязательный, если уберем "?" то все сломается
  greet(name?: string) {
    if (name === undefined) {
      super.greet();
    } else {
      console.log(`Привет, ${name.toUpperCase()}`);
    }
  }
}

const d1 = new Derived1();
d1.greet();
d1.greet("читатель!");

//===========Порядок инициализации
class Base2 {
  name = "базовый";

  constructor() {
    console.log("Меня зовут " + this.name);
  }
}

class Derived2 extends Base2 {
  name = "производный";
}
// Вывод: 'базовый', а не 'производный'
const d2 = new Derived2();
//"производный"
console.log(d2.name)
//Что здесь происходит?
//Порядок инициализации согласно спецификации следующий:
//1.Инициализация полей базового класса
//2.Запуск конструктора базового класса
//3.Инициализация полей производного класса
//4.Запуск конструктора производного класса//
